# Project Rules

You are an expert frontend developer specializing in React 19, Tailwind 4,
and TypeScript. Follow these rules strictly when generating code.

## Core Technologies

- React 19
- NextJS 16
- TypeScript (strict mode)
- Tailwind CSS 4

## TypeScript

- Always use TypeScript with strict mode.
- Prefer `interface` for object shapes, `type` for unions/compositions.
- NEVER use `any` - use `unknown` or proper types.
- Avoid type assertions (`as`) - use type guards or validation instead.
- Enable `noUncheckedIndexedAccess` for array safety.

## React & Next.js

- Default to Server Components.
- Only use `"use client"` when absolutely necessary:
  - Event handlers (onClick, onChange, etc.)
  - React hooks (useState, useEffect, useContext)
  - Browser APIs (localStorage, window, document)
  - Third-party libraries that require client-side rendering
- Use Server Actions for mutations (mark with `"use server"`).
- Implement proper loading states with `loading.tsx` and Suspense boundaries.
- Use `error.tsx` for route-level error handling.
- Async Server Components should handle their own data fetching.
- Use parallel data fetching - do not waterfall requests.
- Implement proper TypeScript types for props - no implicit any.
- Utilize App Router for routing and implement proper error boundaries.
- Use Next.js built-in components (`Image`, `Link`, `Script`) where appropriate.
- Use URL query parameters for server state where it improves UX and shareability.
- Use component libraries like Shadcn UI or React Aria Components.

## Component Design

- Maximum 200 lines per component (including types).
- Components should have a single responsibility.
- Use composition over prop drilling (max 3 levels).
- Prefer compound components for complex UI patterns.
- Extract repeated logic into custom hooks.
- Props must have explicit TypeScript interfaces.
- Use discriminated unions for conditional props.
- Define components using the `function` keyword.
- Avoid unnecessary client components; wrap client components in Suspense with a fallback.
- Build and style React Aria primitives inside `@repo/ui` components.
- In app packages (for example `apps/food-diary`), use `@repo/ui` components and
  do not import `react-aria-components` directly unless explicitly approved.

## File Naming & Organization

```text
src/
├── app/                  # Next.js App Router
├── components/
│   ├── ui/              # Reusable UI (Button, Input, etc.)
│   └── features/        # Feature-specific components
├── lib/                 # Utils, configs, helpers
├── hooks/               # Custom React hooks (useXxx)
├── actions/             # Server Actions (xxxAction.ts)
├── types/               # Shared TypeScript types
└── styles/              # Global CSS, Tailwind config
```

- Components: `PascalCase.tsx` (UserProfile.tsx).
- Utilities: `camelCase.ts` (formatDate.ts).
- Hooks: `useCamelCase.ts` (useAuth.ts).
- Server Actions: `camelCaseAction.ts` (createUserAction.ts).
- For component/context modules, keep public type definitions and exports in
  `index.ts` as the single import entry point.
- Every component module must use a folder with an `index.ts` barrel.
- Public prop/type interfaces for a component module must be declared in that
  module's `index.ts` and imported from there.
- Required component module structure:
  `src/components/ComponentName/ComponentName.tsx`
  `src/components/ComponentName/index.ts`
- Keep component stories and view/helper files inside the same component folder.
- Local utility functions for a component must live in:
  `src/components/ComponentName/utils/`.
- Local hooks for a component must live in:
  `src/components/ComponentName/useFunctionName.ts`.
- If a utility or hook is reused by a second component, move it out of the
  component folder to a shared location at `src/` level (same level as `lib`):
  `src/utils/functionName.ts` or `src/hooks/useFunctionName.ts`.
- Reusable server actions across components must live in
  `src/app/actions/` and be re-exported through
  `src/app/actions/index.ts`.
- If a component file contains multiple internal UI pieces (cards/items/panels),
  extract each piece into `partials/`:
  `src/components/ComponentName/partials/PartName.tsx`.
- Keep the main component/view file focused on composition and wiring only.

## Naming & Formatting

- Use two spaces for indentation; limit line length to 80 characters.
- Use double quotes everywhere, include in JSX attributes; always use semicolons.
- Use strict equality (`===`); add spaces after keywords and around operators.
- Use trailing commas where possible; always parenthesize arrow-function parameters.
- Eliminate unused variables.
- Event handlers start with `handle*`.
- Boolean vars start with verbs (`isLoading`, `hasError`, `canSubmit`).
- Custom hooks start with `use*`.
- Hooks/utilities/actions must contain a single exported function per file.
- File names for hooks/utilities/actions must match the function name exactly
  (`useAuthButtons.ts`, `getInitialSaveState.ts`, `mergeGuestEntries.ts`).
- Prefer full words.
- Allowed short forms: `err`, `req`, `res`, `props`, `ref`.

## Function Style

- Prefer named function declarations for exported functions and components.
- Use function declarations for Server Components and Server Actions.
- Use arrow function expressions assigned to `const` for callbacks and small local utilities.
- Avoid creating functions inline in JSX when it harms performance or readability.
- Avoid anonymous exports; exported APIs must be named.
- Do not use `React.FC`.
- Keep functions focused and short; extract helpers when functions grow beyond ~50 lines or multiple responsibilities.
- Rely on declaration hoisting for organization when helpful.
- Do not rely on hoisting of function expressions or `var`.
- Annotate parameters and return types on exported functions.
- Allow local inference for obvious internal helpers.

## Performance Optimization

### When to Apply

- Use `React.memo` only for expensive components with stable props.
- Use `useMemo` for computationally expensive calculations.
- Use `useCallback` only when passing callbacks to memoized children.
- Do not optimize prematurely - measure first.
- Avoid inline function definitions in JSX where it harms perf or readability.
- Use dynamic imports for non-critical components to improve TTI.
- Do not use `React.memo()` unless proven necessary.
- Do not use `useCallback` for memoizing callback functions by default.
- Do not use `useMemo` for expensive computations without measurement.

## Accessibility Requirements

### Must Implement

- Use semantic HTML (`nav`, `main`, `article`, `section`, etc.).
- Include proper ARIA labels for icon-only buttons.
- Ensure keyboard navigation works (tab order, Enter/Space handlers).
- Maintain color contrast ratios (WCAG AA minimum).
- Form labels must use `htmlFor` attribute.
- Include alt text for all images.
- Support screen readers with proper ARIA attributes.
- Manage focus order and visibility effectively.
- Follow logical heading hierarchy.

## Error Handling, Validation, and Boundaries

- Use Zod for schema validation and clear error messages.
- Add error boundaries with user-friendly fallbacks for client trees.

## Internationalization

- Implement locale detection where relevant.
- Format numbers, dates, and currencies appropriately.
- Support RTL if needed.

## Forbidden Patterns

### Never Do This

- Use `any` type.
- Use `as` type assertions without justification.
- Create client components unnecessarily.
- Use inline styles instead of Tailwind.
- Use raw Tailwind colors (`bg-blue-600`).
- Use arbitrary Tailwind values (`[#fff]`, `[20px]`).
- Create a `tailwind.config.ts` file.
- Use `useEffect` for data fetching in Server Components.
- Create components over 200 lines.

## Documentation

- Use JSDoc for public APIs.
- Include examples where helpful.
- Keep docs concise, correct punctuation, headings, lists, and links.

- Follow `.cursor/communication.mdc`.
- Follow `.cursor/component-stack.mdc`.
- Follow `.cursor/styles-rules.mdc`.
- Follow `.cursor/testing-rules.mdc`.
